# One Thousand Ideas for Computing

# 1. Digital Contracts

Contracts should be digitised so that anyone on any side of any contract can see what they are responsible for and any actions they can take within the contract. There should be a UI for interacting with the contract. If I have a contract with a company to do with my private data, I should be able to request data through the UI. Or if If I have a phone contract and I am eligible for an upgrade, I should be able to upgrade through the UI.

# 2. Mobile legal business creation and Personal ERP

Someone with a phone should be able to just create a business that satisfies all reporting requirements and is a legal entity. I want to see a mobile phone app that implements enterprise resource planning for the gig economy.

# 3. Telework

Computational problems can be rendered into labelled graphical video streams upon which people vote. People can solve computational problems with a television monitor, numbered graphs and a keypad that they enter sequences of numbers into. Problems like efficient scheduling of cars for carpooling or deliveries are solvable by human beings quickly with a user interface that allows one to lasso points on the map and add cars. This is for problems that are not strictly numerical.

# 4. Paper Work Language

We need a way to define work. All work can be represented digitally. This standard is that a piece of work must fit on an A4 piece of paper. A bit like a job description but each page represents a task. So you have a piece of A4 paper describing one piece of work to do. Each piece of work can depend on other pieces of work. Can be integrated into a continuous integration pipeline for human beings. Work appears in your work inbox.

Existing:

* BPMN Business Processs Modelling Notation
* JBPMN

# 5. Open Demand Mapping

People can insert demands for products and services into a demand marketplace within a geographical location. I want a dentist within 5 minutes walk of my home. I want a supermarket within 5 minutes walk of my home. In aggregate, people create demands on their local areas.

# 6. Lifestyle subscriptions

There's a single app for following any dream or any lifestyle with user created content. You pay money per month for some thing you want to do, maybe a healthy eating, hobby, sports or gym. Maybe you want to become a musician or you want a lifestyle where you live in suburbs. The company sends you recommended decisions to make, materials and gear that you need for your level of subscription. So if you said you want a lifestyle where you can get to work within 25 minutes, the app would tell you where to move to.

https://lifestyle-subscriptions.com

# 7. Human Query Engine

An filled inbox of questions to answer and questions generated based on my answers to previous questions. Like a chat bot that messages you instead of you messaging it. Uses random lists of words to ask interesting questions such as "Is **thingA** better than **thingB**" or "How much money do you have in your bank account?". The data collected could be used to implement [life engine](https://github.com/samsquire/ideas#5-life-engine).

# 8. Active Slides

It should be possible to make decisions in a company via presentation software if slides accurately represent processes of the company and through data collection within the presentation software. Presentation software becomes an interactive system. I imagine anybody can connect to the presentation software via mobile device by Wifi. I imagine presentations depictions of models (flow diagrams) and frameworks (smartart) could be executable by a workflow engines. So how companies say they are going to run, is actually how they run. There could be an app store of integrations with presentations for showing information that is up-to-date and live; such as pulling in sales data from internal systems.

# 9. Scheduled Society and Virtual Placements

Human suffering could be eliminated if everyone had a virtual placement assigned. Everyone can have what they need and want if every other thing is at the right place at the right time. Place is virtual. There are virtual places such as receive X amount of Y food at Z, shop at X, sleep at X, be at X, receive X, go to X, take A to B, Complete X amount of Y work. Do Y at X time. Everyone has a set of places at any given time. Not everyone needs a virtual place at all times. If virtual places are scheduled, traffic, commuting, waiting can be eliminated. Placement is representation of a position to take in the world - it could be a place in a queue. Everyone can buy and sell placements and schedules. Basically every thing is a market and it can be financialised.

# 10. Library Mesh

Depending on a library could also involve pinging the libraries' software infrastructure so that whenever the library is changed, the dependents are also rebuilt. This would catch code that causes downstream changes to APIs. API changes are expensive.

# 11. Additive GUIs

Represent the commands that generate GUIs as a monotonically increasing set of statements about the GUI and declaratively render a GUI based on propositions of widgets in relationship to one another. Has the property of being able to extend existing GUIs by simply making more statements. See http://github.com/samsquire/additive-guis Imagine if a set of tweets could render a GUI.

# 12. Recommended music for webpage

Wouldn't it be nice if you could recommend a song to play with a web page as background music.

# 13. GUIs are queries

The entire GUI could be generatable as response to a query.

# 14. User URLs

As the user mouses around the GUI, a URL should be generated which is a representation of what the user is doing at any point in time including all context from the user's perspective. This is like a very deep link into an application, as the user is a resource. See https://github.com/samsquire/user-urls

# 15. Free flowing work app

Replace job interviews at individual companies with interviews with an app company to vet people for a certain kind of role. People can look at shop exterior and see a logo of an Accreditation  company and work there if they have been vetted by the app. Transport can be branded by Accreditation company and accreditation app companies can specialise in the quality of the people they hire.

# 16. Cloud accelerated desktops

Desktop computers could be accelerated by doing things remotely. If a user's filesystem is mirrored elsewhere, it can be searched remotely and results served locally without incurring any performance penalty locally. See https://github.com/samsquire/cloud-desktop

# 17. Data Bento Box

An app that downloads data from various sources online to fill 1 gigabyte of data (reddit, blog posts, articles, free books), implements a viewer and always gives you something to read while you're offline.

# 18. CMS for building webapps

A CMS for webapps: create serverside and clientside routes, register handlers from a GUI.

# 19. Stack-upon

The OSI model makes a whole deal of sense, one layer adds promises on-top of the layers below to create an emergent complexity. Each layer makes promises to other layers. What if we had a visualization of a multi layered spreadsheet whereby each layer is a layer of the architecture of the software. Each layer is like a line in your stacktrace at the same abstraction level. In addition to formula cells representing computation, we have references that represent communication between different labelled cells. Passing data between layers is an interface which either takes you to a layer above or below to where you are at. This is where enterprise service bus mapping screens would come in handy.

# 20. Credit cards to tap into buildings

Credit cards can be used to access buildings.

# 21. API Promises - Dependency on Larger-than-an-Interface

Churn is painful in software development. Things change without warning and things no longer compile or work together. I would like to see a more mature strategy to breaking changes and how they ripple through a software ecosystem. Software change is not cheap. Python 3 is some thing I'd like to avoid going forward. I want to depend on some thing that shouldn't break, that means depending on an abstraction or interface but is depending on some thing much larger than a single interface in code. I call this an API promise. The API I depend on should not break between major releases, it's stable and it's locked into the software. Javascript in the browser keeps working but my NodeJS, Ruby and Java projects break all the time due to refactoring being done on underlying dependencies. Developers need accurate statistics of code coverage of who is using what. They also need to know if they've broken some thing downstream with their changes.

# 22. 








 
